# Product Requirements Document (PRD) for Stock Trading Bot
Generated by GROK on 2025-08-22, see prompt.txt for initial request.

## 1. Overview
### 1.1 Purpose
The Stock Trading Bot is a Python-based command-line application that uses a LightGBM model to analyze historical stock price data and generate buy/sell signals for paper trading simulations (e.g., Interactive Brokers). It processes a CSV file with stock prices and indicators, trains a model to predict buy signals based on a 15-candle price increase, and produces a backtested output CSV with trade signals, stop-loss, and target prices, adhering to a 3:1 risk-reward ratio and a 2-day maximum position duration.

### 1.2 Target Audience
- Individual traders experimenting with algorithmic trading.
- Developers or analysts testing LightGBM-based strategies for paper trading.
- Users familiar with Python and CSV-based data workflows.

### 1.3 Goals
- Train a LightGBM model to predict buy signals based on historical stock data.
- Generate buy/sell signals without look-ahead bias.
- Add columns for buy signals, stop-loss (1% risk), and target price (3:1 ratio).
- Produce a backtested CSV file for paper trading simulations.
- Ensure positions are closed within 2 days.

## 2. Features
### 2.1 Data Ingestion
- **Description**: Import and validate a CSV file with stock price data and indicators.
- **Details**:
  - Expected columns: `Date`, `Close`, `High`, and technical indicators (e.g., RSI, MACD, SMA).
  - Validate data for missing values and correct formats.
  - Handle daily or intraday candle data (user-specified).
- **Priority**: High

### 2.2 Model Training
- **Description**: Train a LightGBM model to predict buy signals.
- **Details**:
  - Target: Buy signal if close price increases by ≥3% within 15 candles (or high price as secondary metric).
  - Features: All indicator columns from the CSV plus `Close` and `High`.
  - Split data into training (80%) and validation (20%) sets.
  - Avoid look-ahead bias by using only past and current data for predictions.
  - Save trained model for reuse in prediction phase.
- **Priority**: High

### 2.3 Signal Generation
- **Description**: Generate buy signals and calculate stop-loss and target prices.
- **Details**:
  - Add column `Buy_Signal` (1 for buy, 0 otherwise) based on model predictions.
  - Add column `StopLoss_Price`: Entry price minus 1% of entry price (e.g., for entry at $100, stop-loss at $99).
  - Add column `Target_Price`: Entry price plus 3% (3:1 ratio, e.g., $103 for $100 entry).
  - Ensure signals respect 2-day maximum position duration (close after 2 days if not already closed).
- **Priority**: High

### 2.4 Backtesting
- **Description**: Simulate trades based on signals and produce a backtested output CSV.
- **Details**:
  - Simulate trades: Enter on buy signal, exit at target price, stop-loss, or after 2 days.
  - Output CSV with columns: `Date`, `Close`, `High`, `Buy_Signal`, `StopLoss_Price`, `Target_Price`, `Sell_Signal`, `Trade_Result` (profit/loss).
  - Calculate metrics: Win rate, total profit/loss, average trade duration.
- **Priority**: High

### 2.5 Command-Line Interface
- **Description**: Allow users to run training and prediction via CLI.
- **Details**:
  - Commands: `train <csv_file>` to train model, `predict <csv_file>` to generate signals and backtest.
  - Output: Backtested CSV file and summary metrics (e.g., win rate, profit).
- **Priority**: Medium

## 3. Technical Requirements
### 3.1 Tech Stack
- **Language**: Python 3.10+.
- **Libraries**: 
  - `lightgbm` (PyPI) for machine learning.
  - `pandas` for data manipulation.
  - `numpy` for numerical operations.
  - `click` for CLI interface.
- **Data Storage**: CSV files for input and output; no database required.
- **Environment**: Local execution, compatible with Pyodide for potential browser-based testing.

### 3.2 Non-Functional Requirements
- **Performance**: Process a CSV with 10,000 rows in < 5 minutes on a standard laptop.
- **Scalability**: Handle CSV files up to 100 MB.
- **Security**: No external API calls or sensitive data handling required.
- **Accuracy**: Model predictions avoid look-ahead bias, validated via backtesting.

## 4. User Flow
1. User runs `train <input_csv>` to train the LightGBM model on the input CSV.
2. Model processes data, creates training/validation splits, and saves the model.
3. User runs `predict <input_csv>` to generate signals and backtest.
4. App adds `Buy_Signal`, `StopLoss_Price`, and `Target_Price` columns.
5. App simulates trades, respecting 2-day position limit, and outputs a backtested CSV.
6. User reviews output CSV and summary metrics for paper trading (e.g., in IBKR).

## 5. Success Metrics
- **Model Accuracy**: Achieve >60% win rate on backtested trades.
- **Risk Management**: All trades maintain 3:1 risk-reward ratio and 1% max loss.
- **Processing Time**: Complete training and prediction in < 5 minutes for 10,000 rows.
- **User Satisfaction**: Clear CLI output and usable backtested CSV for paper trading.

## 6. Constraints
- **Budget**: Development within a $3,000 budget for MVP.
- **Timeline**: MVP completed in 6 weeks.
- **Team**: 1 developer with Python and LightGBM experience.
- **Data**: User provides CSV with stock data and indicators.

## 7. Assumptions
- Input CSV has consistent format with `Date`, `Close`, `High`, and indicator columns.
- “Significant” price increase is ≥3% in close price over 15 candles (adjustable).
- No real-time trading or exchange API integration is required.
- Paper trading will be conducted manually using output CSV in platforms like IBKR.

## 8. Future Considerations
- Add support for intraday data with different candle intervals (e.g., 1-hour, 5-minute).
- Integrate with IBKR API for automated paper trading.
- Add visualization of backtest results (e.g., using Matplotlib).
- Support multiple models (e.g., XGBoost) for comparison.

## 9. Milestones
- **Week 1**: Set up project, validate CSV ingestion, and define data schema.
- **Week 2-3**: Implement LightGBM model training and signal generation.
- **Week 4**: Develop backtesting logic and stop-loss/target price calculations.
- **Week 5**: Build CLI and test end-to-end workflow.
- **Week 6**: Optimize performance, validate no look-ahead bias, and deliver MVP.